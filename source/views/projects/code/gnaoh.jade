extend /views/skeleton
block content
    section
        h3 Objectives:
        ul.inline
            li Learning experience
            li Showcase things I've made
            li Put the free year of Amazon micro EC2 server to use (besides being a VPN/wiki/file server)
    section
        h3 Clone and server gnaoh locally:
        pre.prettyprint.
            git clone https://github.com/crystol/gnaoh.git
            cd gnaoh
            curl https://raw.github.com/jrburke/requirejs/master/require.js >> source/js/require.js
            npm install
            grunt clone
        | Point browser to 
        +link('http://localhost:1337/projects', 'localhost:1337')
    section
        h3 Trials and tribulations of gnaoh
        .textblock.
            Node.js running Express is the application behind everything that you see on this website.
            When it's serving requests on its own, it tends to choke a bit on this single core powered server.
            A simple flood benchmark, normalized to 5000 total requests and 250 concurrent, shows its relative capacity.
        img(src='')
        .textblock.
            It's even worse at serving pages over the TLS protocol.
        img(src='')
        .textblock.
            Nginx is added as an indentured servant--aka the serving workhorse.
        pre.prettyprint.
            # Node.js server
            upstream node {
                server 127.0.0.1:8080;
            }
            # Main route to node server
            location @proxy {
                proxy_set_header   Host             $http_host;
                proxy_set_header   X-Real-IP        $remote_addr;
                proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;
                proxy_set_header   X-NginX-Proxy    true;
                proxy_pass         http://node;
            }
            # Cache settings
            proxy_cache              proxycache;
            proxy_cache_path         /kadmin/server/nginx/temp/proxycache levels=1:2 keys_zone=proxycache:5m max_size=1000m inactive=600m;
            proxy_cache_valid        any 1m;
            # Open cache
            open_file_cache          max=1000 inactive=30s;
            open_file_cache_valid    30s;
            open_file_cache_min_uses 2;
        .textblock.
            Much of the stress on node.js was alleviated when nginx served all of the static contents requested.
            To top it off, Nginx even proxy caches all of the pages generated by Express. 
            In tandum with open cache for regular files, this system is much more efficient than the standalone node.js application.
            How great!
        img(src='')
        pre.prettyprint.
            location / {
                 add_header Cache-Control 'public, max-age=3600, must-revalidate';
                 try_files $uri $uri.html @proxy;
            }
        .textblock
            | Nginx handles TLS encryption with ease. 
            | Gnaoh's certificate was a free-tier (hey, the best things in life are free right?) obtained from
            +link('http://www.startssl.com', 'StartSSL')
            | . Considering the future of the
            +link('http://lists.w3.org/Archives/Public/ietf-http-wg/2013OctDec/0625.html', 'HTTP/2') 
            | protocol, it's neat to explore the seemingly endless depdths of crytography. 
        .textblock.
            The ciphers scheme used with gnaoh was eventually deduced with a few key points
        ul.inline 
            li SSL is completely disabled
            li Forward secrecy is supported in newer browsers
            li Oldest supported protocol is 128 bit RC4 over TLSv1
            li Elliptic curve Diffieâ€“Hellman key exchange protocol for 128bit AES encryption seem to perform the best without hindering other functionality 
        pre.prettyprint.
            ssl_prefer_server_ciphers on;
            ssl_protocols  TLSv1 TLSv1.1 TLSv1.2;
            ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-RC4-SHA:HIGH:!EDH:!MD5:!aNULL;
        .textblock.
            The hit to server performance is definitely justifiable considering the features that SPDY offers:
            stream multiplexing, headers compression, and the ability for the server to send data before it's even requested.
        .textblock.
            To further optimize the flow, a Grunt task was written to bear the burden of pre-rendering each route that exists for this application.
            This task is feasible due to the fact that this is a personal website with minute amounts of data--that's not managed by a database.
        pre.prettyprint.
            // Grunt task to convert all jade templates to .html files
            'use strict';
            module.exports = function (grunt) {
                grunt.registerTask('renderHTML', function () {
                    var fs = require('fs');
                    var jade = require('jade');
                    var mkdirp = require('mkdirp');
                    var buildDir = process.cwd() + '/build/';
                    var routesList = require(buildDir + '/router.js');
                    // Writes the generated html to file
                    function write(error, html) {
                        if (error) {
                            throw error;
                        }
                        // Make the directory if it doesn't exist
                        var routeFrags = route.split('/');
                        var htmlDir = buildDir + 'public/' + routeFrags.slice(0, routeFrags.length - 1).join('/');
                        if (routeFrags.length > 1 && !fs.existsSync(htmlDir)) {
                            mkdirp.sync(htmlDir);
                        }
                        var htmlFile = buildDir + 'public/' + route + '.html';
                        fs.writeFileSync(htmlFile, html);
                        console.log('Generated ' + htmlFile);
                    }
                    // Loop through the routes list and call write function for each.
                    for (var route in routesList) {
                        var jadeFile = buildDir + 'views/' + route + '.jade';
                        jade.renderFile(jadeFile, routesList[route].options, write);
                    }
                });
            };

